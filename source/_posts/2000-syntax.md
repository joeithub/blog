title: SQLAlert 语法
tags:
  - SQLAlert
categories:
  - IT
author: Joe Tong
date: 2019-06-22 07:17:00
---

# RDL 语法
RDL 脚本汲取了其他编程语言较好的语法格式，并进行了一定的修改，以达到相同的功能使用户输入最少的内容。

## 语句与注释
RDL 脚本以语句为单位执行，每条执行语句必需以分号（;）结束。使用花括号（{}）来指定语句块，语句块可以不以分号（;）结束，但语句块内的每条语句都必需以分号（;）结束。例如下述代码片断，都是有效的语句：

> ~~~ {.id .cs .numberLines}
> print("world");         // 单独的语句
> 
> {                       // 包含两条语句的语句块
>     print("hello");
>     print("world");
> }
> ~~~

在上述代码片断中，第 1 行与第 5 行为注释内容。在 RDL 脚本中可以用 # 和 // 来对内容进行注释，从 # 或 // 开始直到行尾均为注释内容，SQLAlert 在解释执行脚本时会忽略所有注释内容。在 RDL 脚本中不支持类 C 语言中的块级注释。

## 数据类型
RDL 支持五种基本的数据类型：（1）数（包括整型与浮点）；（2）字符串；（3）数组（List）；（4）字典（Dict）；（5）布尔（true、false），熟悉 JSON 的读者应该知道这四种数据均为 JSON 支持的数据类型。如下代码片断所示，为四种数据类型的示例：

> ~~~ {.id .cs .numberLines}
> // 数（整型与浮点）, 支持 10 进制整数、16 进制整数、10 进制浮点数。
> 123456    0xFF    0xFF    123.456
> // 字符串，支持单引号（'）、双引号（"）、反引号（｀）。
> 'string'    "string"    `string`
> // 数组，元素可以是任意类型数据与表达式。
> [ 123, 'string', 100 + 200, {"name": "zhang"}, [1, 2, 3] ]
> // 字典，KEY 只能为字符串；VALUE 可以是任意类型数据与表达式。
> { "value": "zhang", "list": [ 1, 2, 3 ], "dict": { "vlaue": 1 } }
> // 布尔类型数据
> true      false
> ~~~

其中字符串、List、Dict 类型的数据均可以分多行定义，但是字符串在多行定义时，换行符也是字符串内容的一部分。

## 变量
RDL 脚本中的变量是无类型（或弱类型）的，不需要任何声明，可以直接赋值使用。将什么类型的数据赋值给变量，则变量就是什么类型。如下述代码片断所示：

> ~~~ {.id .cs .numberLines}
> a = 123;                      // 将整型赋值给变量 a，  则变量 a 即为整型；
> a = "a string";               // 将字符串赋值给变量 a，则变量 a 即为字符串；
> a = [ 1, 2, 3 ];              // 将 List 赋值给变量 a，则变量 a 即为 List；
> a = { "value": [ 1, 2, 3 ] }; // 将 Dict 赋值给变量 a，则变量 a 即为 Dict；
> ~~~

如果一个变量在使用前没有赋值任何值，则这个变量的值为 null，表示空。数值 null 也可以单独作为一个值来使用，其地位与基本数据类型是一样的。

**需要注意**，变量名不能包含特殊字符及 RDL 脚本预置的所有符号。可以包含下划线与数字，但不能以数字开头。

## 字符串中的变量
在定义字符串时，可以使用 %(name) 来引用当前执行环境中的变量值，相当于字符串的格式化。其中，name 为变量的名，如下述代码所示：

> ~~~ {.id .cs .numberLines}
> a = "zhang";
> b = 123;
> print("a = %(a); b= %(b); c = %(c)");
> ~~~

执行该示例代码后，得到如下输出内容：

> ~~~ {.id .cs}
> a = zhang; b= 123; c = null
> ~~~

其中，%(a) 被变量 a 的值（字符串 zhang）替换； %(b) 被变量 b 的值 （整数 123）替换； 对于 %(c)，由于变量 c 没有定义，被替换成 null。

## 表达式
RDL 脚本支持五种算术表达式：加（+）、减（-）、乘（*）、除（/）、取余（%）；六种比较表达式：小于（<）、小于等于（<=）、大于（>）、大于等于（>=）、等于（==）、不等于（!=）；三种逻辑表达式：且（&&, and）、或（||, or）、否（!, not）。

表达式之间可能使用括号 () 进行无限嵌套，括号内的操作符优先级将高于括号外的操作符。如下代码片断给出了表达的部分示例：

> ~~~ {.id .cs .numberLines}
> a = ((1 + 5) * (4 - 2)) / 3;
> print("a =", a);
> 
> b = (100 >= 200) && (1 > 2);
> print("b =", b);
> ~~~

与其它编程语言一样，操作符 否（!, not）为单目操作符，其它均为双目操作符。除此之外，RDL 还支持一种三目操作符，... ? ... : ... 熟悉 C 或 java 的读者应该对这种三目操作符比较熟悉。下面给出该三目操作符的使用示例：

> ~~~ {.id .cs .numberLines}
> name = 100 > 200 ? 'zhang' : 'wang';
> print("name =", name);
> ~~~

上述代码中，比较表达式 100 > 200 的值为假（false）所以赋值语句将字符串 'wang' 赋值给变量 name。

## 分支语句
RDL 脚本支持 if expr { } else if expr { } else {} 分支，根据条件来执行不同的语句块，语句块必需包含在花括号内，花括号后面不需要以分号结束。条件表达式可以是任务类型的数据、表达式或者函数，可以包含在括号（）内，也可以不使用括号。

分支语句示例：

> ~~~ {.id .cs .numberLines}
> if      a > 200 { do_something(); }
> else if a > 100 { do_something(); }
> else            { do_something(); }
> ~~~

分支语句中，必需以 if 分支开始，中间可以有多个 else if 分支，也可以没有，结尾可以出现 else 分支，也可以没有，但最多只能有一个。

## 循环语句
RDL 脚本中支持 for 循环语句，包括（1）for expr { } 和（2）for init; cond; next { } 两种形式，第一种形式类似于 C 中的 while 循环。

第（1）种 for 循环示例，打印出 0 ~ 9 的 10 个数字，代码如下：

> ~~~ {.id .cs .numberLines}
> a = 0;
> for (a > 10) {
>     print("a =", a);
>     a ++;
> }
> ~~~

第（2）种 for 循环示例，同样打印出 0 ~ 9 的 10 个数字，代码如下：

> ~~~ {.id .cs .numberLines}
> for a = 0; a < 10; a ++ {
>     print("a =", a);
> }
> ~~~

循环中支持 continue 和 break 关键字，同时支持循环的嵌套。

## 函数定义
RDL 脚本中通过关键字 def 来定义函数，示例如下：

> ~~~ {.id .cs .numberLines}
> def my_print(value) {          // value 为函数的参数
>     print("value =", value);
> }
> my_print("zhang");             // 函数调用
> ~~~

函数定义中支持使用 return 关键字从函数中退出，同时可以指定函数的返回值。

## 文件包含
RDL 脚本中可以通过 include 和 import 两个关键字来包含或者引入另一个 RDL 脚本文件。示例代码如下：

（1） 第一个脚本文件 test1.rule：

> ~~~ {.id .cs .numberLines}
> def test_print(value) {
>     print("value =", value);
> }
> ~~~

（2）在第二个脚本文件中包含第一个脚本文件（test2.rule):

> ~~~ {.id .cs .numberLines}
> include "test1.rule";
> test_print("zhang");          // 在脚本文件 test1.rule 中定义
> ~~~

上述代码示例中，在脚本 test2.rule 中调用了 test1.rule 中定义的函数 test_print()，在 test2.rule 中同时还可以引用 test1.rule 中定义的任何变量。

在 RDL 脚本中，可以在任意位置使用 include 和 import 来包含另一个脚本文件，二者的唯一区别是：通过 include 包含的脚本只会被执行一次，被引用的脚本只会在第一次 include 的时候执行；而通过 import 引入的脚本每次都会被执行，后面执行的结果将会覆盖前面的执行结果。另一个代码示例：

> ~~~ {.id .cs .numberLines}
> // 脚本文件 test1.rule 内容
> name = "zhang";
> age  = 18;
> 
> def print_name_age() {
>     print("name =", name, "age =", age);
> }
> 
> 
> // 脚本文件 test2.rule 内容
> name = "wang";
> 
> include "test1.rule";
> 
> age  = 25;
> print_name_age();
> ~~~

请读者自行验证该示例的输出内容。

